# Debug Galileo

Mostly it is related to connection problem.

### DHCP Server Mis-configuration
Just connect a normal device (your cell phone, laptop) to your DHCP server. If it works, your DHCP server is fine.

### Network Problem
If you think maybe it is the network problem, the routing process is wrong, try assign Galileo a static IP to make things simpler. Mount the image's file system on your host by `mount -t ext3 -o loop image-full-galileo-clanton.ext3 /tmp/sdcard` and edit `/etc/network/interfaces` to assign `eth0` a static IP and gateway. They manually set up path from your host by adding static arp entry `arp -s static-ip-of-galileo mac-of-galileo`. If all these does not work, your image could be corrupted.

### Corrupted Image
1. Are you using partition type `master boot record` with a `FAT32` partition?
2. Did you rename the files corrected? Maybe you delete one more character?
3. Did you copy the images from the same build? For example, every build updates `image-full-galileo-clanton.ext3`, and `core-image-minimal-initramfs-clanton.cpio.gz`. Combining two files from different build might not work.


### Illegal instruction (`SIGILL`)
Usually this is due to the wrong flag during cross compilation. `SIGILL` is sent to a process if it tries to execute an illegal machine-language instructions. Two possible cases are

1. Incorrectly formed machine-language instruction by compiler. In this case, you are probably helpless as you need to fix your compiler.... Usually though, gdb is fairly stable, you get `SIGILL` because of the second case.
2. Your CPU encounter a unknown instruction (note from CPU's point of view, an illed-formed instruction is the same as an unknown instruction).

The unknown instruction could be generated by your compiler when you issued the wrong flag during cross compilation. But if you cross compiled a bunch of stuff, and the dependencies are a huge mess, how do you quickly know which program or libraries contains the illegal instruction.?

The answer is core dump. A core dump is a file containing a memory image of the process at the time it terminated. (The term core derives from an old memory technology.) This memory image can be loaded into a debugger in order to examine the state of a programâ€™s code and data at the moment when the signal arrived.